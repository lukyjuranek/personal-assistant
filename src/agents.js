import { getConversation } from './memory.js';


/*
 * Gets relevant user context for plannerAgent. Gets messages, memory, reminder etc.
 */
export async function contextBuilder(userId) {
  return "";
}


/*
 * Takes the input message, the context and plan the relevant taks to be done
 */
export async function plannerAgent(model, message, context, userid) {
  const promptFile = Bun.file('./prompts/planner.md');
  const promptTemplate = await promptFile.text();

  const prompt = `${promptTemplate}

---
Context: "${message}"
Message: "${message}"
`;

  const response = await model.invoke(prompt);
  const jsonMatch = response.content.match(/\{[\s\S]*\}/);

  if (!jsonMatch) {
    return { isSchedule: false };
  }


  return response.content;
}

// TODO:
// Use LangGraph over LangChain agents for multi-agent flows — it gives you explicit state management and conditional routing, which is critical here.
// Memory extraction prompt — after each conversation turn, run a background call to Gemini asking: "Extract any important personal facts or preferences from this message" and save them to the vector store.
// Tool calling — define your tasks/reminders as Gemini function-calling tools. Gemini 1.5 Pro handles this very well and will reliably call create_task(title, deadline) when it detects intent.
// Proactive reminders loop — run a lightweight cron job every few minutes that asks the inference agent: "Given the user's tasks and current time, is there anything I should surface right now?
// Consider adding the weather tool
/***
 * Analyzes suggested memory updates and decides what is durable.
 */
//export async memoryAgent(model, planner_output){

//}

export async function responderAgent(model, plan) {
  const prompt = `
You are a responder agent that reads the input message, the task generated by the planner agent. Your job is create a message to send back to the user.
Planner agent output: ${plan}

Reply ONLY with a valid message in this format:
Response to the some of the explicit tasks that require an answer.

task executed | task executed | ...


Example input and output:
....

Here are top things to do in Madrid: ....

Meomory updated: has girfriend, lives in madrid | Reminder set for 9am
`

  const response = await model.invoke(prompt);

  return response.content;
}

/*
  * Agent that runs every once in a while a check whether there is something to be resurfaced
  */
export async function proactiveAgent(model, context) {
  const datetime = new Date().toISOString();
  const prompt = `
Given the user's tasks and current time, is there anything I should surface right now?
Current time and date: ${datetime}
Context: ${context}

Respond ONLY with a mesage for the user regarding the thign you think should be resurfaced.
`
  const response = await model.invoke(prompt);

  return response.content;
}

// Detect if user wants to schedule something
export async function detectScheduleIntent(model, message, userId) {
  const history = getConversation(userId);
  const prompt = `Analyze this message and determine if the user wants to schedule a task or reminder.

Conversation history:
${history.map(m => `${m.role}: ${m.content}`).join('\n')}

Message: "${message}"

Reply ONLY with valid JSON in this exact format (no other text):
{
  "intent": "create_schedule" | "edit_schedule" | "delete_schedule" | "list_schedules" | "chat",
  
  // For create_schedule:
  "type": "prompt" or "reminder",
  "frequency": "once" | "daily" | "weekly" | "monthly",
  "dayOfWeek": 0-6 or null,
  "dayOfMonth": 1-31 or null,
  "scheduledDate": "YYYY-MM-DD" or null,
  "time": "HH:mm",
  "content": "the task or reminder text",

  // For edit_schedule:
  // Look at conversation history to find the schedule being referred to
  // "it", "that", "the reminder" etc. refer to the most recently mentioned schedule
  "scheduleId": number or null (if known from history),
  "updates": {
    "time": "HH:mm" or omit,
    "content": "text" or omit,
    "frequency": "once/daily/weekly/monthly" or omit,
    "dayOfWeek": 0-6 or omit,
    "dayOfMonth": 1-31 or omit,
    "scheduledDate": "YYYY-MM-DD" or omit,
    "type": "prompt/reminder" or omit
  },

  // For delete_schedule:
  "scheduleId": number or null,

  // For chat:
  "response": "your conversational response"
}

Time interpretation:
- "morning" = "09:00"
- "afternoon" = "14:00"  
- "evening" = "18:00"
- "night" = "20:00"

Important: Use the conversation history to understand context.
If the user says "change it to 2pm", look back in history to find what schedule they created or mentioned last.`;

  const response = await model.invoke(prompt);
  const jsonMatch = response.content.match(/\{[\s\S]*\}/);

  if (!jsonMatch) {
    return { isSchedule: false };
  }

  console.log("Prompt:" + prompt);
  console.log("Response: " + response);

  return JSON.parse(jsonMatch[0]);
}

