import type { BaseMessage } from "@langchain/core/messages";
import { getConversation } from "./memory";

export interface ChatModelLike {
  invoke(
    input: string | BaseMessage[]
  ): Promise<{ content: string }>;
}

export async function contextBuilder(userId: string): Promise<string> {
  return "";
}

export async function plannerAgent(
  model: ChatModelLike,
  message: string,
  context: string,
  _userId: string
): Promise<{ isSchedule?: boolean } | string> {
  const promptFile = Bun.file("./prompts/planner.md");
  const promptTemplate = await promptFile.text();

  const prompt = `${promptTemplate}

---
Context: "${message}"
Message: "${message}"
`;

  const response = await model.invoke(prompt);
  const jsonMatch = (response.content as string).match(/\{[\s\S]*\}/);

  if (!jsonMatch) {
    return { isSchedule: false };
  }

  return response.content as string;
}

export async function responderAgent(
  model: ChatModelLike,
  plan: string | { isSchedule?: boolean }
): Promise<string> {
  const prompt = `
You are a responder agent that reads the input message, the task generated by the planner agent. Your job is create a message to send back to the user.
Planner agent output: ${typeof plan === "string" ? plan : JSON.stringify(plan)}

Reply ONLY with a valid message in this format:
Response to the some of the explicit tasks that require an answer.

task executed | task executed | ...


Example input and output:
....

Here are top things to do in Madrid: ....

Meomory updated: has girfriend, lives in madrid | Reminder set for 9am
`;

  const response = await model.invoke(prompt);
  return response.content as string;
}

export async function proactiveAgent(
  model: ChatModelLike,
  context: string
): Promise<string> {
  const datetime = new Date().toISOString();
  const prompt = `
Given the user's tasks and current time, is there anything I should surface right now?
Current time and date: ${datetime}
Context: ${context}

Respond ONLY with a mesage for the user regarding the thign you think should be resurfaced.
`;
  const response = await model.invoke(prompt);
  return response.content as string;
}

export interface ScheduleIntent {
  intent: "create_schedule" | "edit_schedule" | "delete_schedule" | "list_schedules" | "chat";
  type?: "prompt" | "reminder";
  frequency?: "once" | "daily" | "weekly" | "monthly";
  dayOfWeek?: number | null;
  dayOfMonth?: number | null;
  scheduledDate?: string | null;
  time?: string;
  content?: string;
  scheduleId?: number | null;
  updates?: Record<string, unknown>;
  response?: string;
}

export async function detectScheduleIntent(
  model: ChatModelLike,
  message: string,
  userId: string
): Promise<ScheduleIntent | { isSchedule: false }> {
  const history = getConversation(userId);
  const prompt = `Analyze this message and determine if the user wants to schedule a task or reminder.

Conversation history:
${history.map((m) => `${m.role}: ${m.content}`).join("\n")}

Message: "${message}"

Reply ONLY with valid JSON in this exact format (no other text):
{
  "intent": "create_schedule" | "edit_schedule" | "delete_schedule" | "list_schedules" | "chat",
  
  "type": "prompt" or "reminder",
  "frequency": "once" | "daily" | "weekly" | "monthly",
  "dayOfWeek": 0-6 or null,
  "dayOfMonth": 1-31 or null,
  "scheduledDate": "YYYY-MM-DD" or null,
  "time": "HH:mm",
  "content": "the task or reminder text",

  "scheduleId": number or null (if known from history),
  "updates": {
    "time": "HH:mm" or omit,
    "content": "text" or omit,
    "frequency": "once/daily/weekly/monthly" or omit,
    "dayOfWeek": 0-6 or omit,
    "dayOfMonth": 1-31 or omit,
    "scheduledDate": "YYYY-MM-DD" or omit,
    "type": "prompt/reminder" or omit
  },

  "scheduleId": number or null,

  "response": "your conversational response"
}

Time interpretation:
- "morning" = "09:00"
- "afternoon" = "14:00"  
- "evening" = "18:00"
- "night" = "20:00"

Important: Use the conversation history to understand context.
If the user says "change it to 2pm", look back in history to find what schedule they created or mentioned last.`;

  const response = await model.invoke(prompt);
  const jsonMatch = (response.content as string).match(/\{[\s\S]*\}/);

  if (!jsonMatch) {
    return { isSchedule: false };
  }

  console.log("Prompt:" + prompt);
  console.log("Response: " + response.content);

  return JSON.parse(jsonMatch[0]) as ScheduleIntent;
}
